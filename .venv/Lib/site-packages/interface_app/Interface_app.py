import os
import platform
import subprocess
import threading
from scapy.all import ARP, Ether, srp

import pyvisa
import time
import numpy as np
import pandas as pd

'''
INDIRIZZI STRUMENTI:
IP: 192.168.1.1, MAC: 54:b8:0a:09:0b:1c -> router?
IP: 192.168.1.11, MAC: 00:19:af:52:91:bf -> spectrum analyzer rigol
IP: 192.168.1.108, MAC: d0:c6:37:7c:7d:a6 -> this computer
IP: 192.168.1.105, MAC: 00:90:b8:28:20:b4 -> oscilloscope
'''

Lab_Instruments = {
  "SA_Rigol":{
    "ip_addr": "192.168.1.11",
    "mac_addr": "00:19:af:52:91:bf"
  },
  
  "Osc_RS":{
    "ip_addr": "192.168.1.101",
    "mac_addr": "00:90:b8:28:20:b4"
  },
  
  "DMM":{
    "ip_addr": "192.168.1.107",
    "mac_addr": ""
  },
  
  "FuncGen_Rigol":{
    "ip_addr": "169.254.106.236",
    "mac_addr": "00:19:AF:04:EC:69"
  },
  
}

def ping(host):
    param = '-n' if platform.system().lower() == 'windows' else '-c'
    command = ['ping', param, '1', host]

    result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    return result.returncode == 0

def get_mac(ip):
    arp_request = ARP(pdst=ip)
    broadcast = Ether(dst="ff:ff:ff:ff:ff:ff")
    arp_request_broadcast = broadcast/arp_request
    answered_list = srp(arp_request_broadcast, timeout=2, verbose=False)[0]

    if answered_list:
        return answered_list[0][1].hwsrc
    else:
        return None

def scan_network(ip_range):
    ip_list = ip_range.split('.')
    base_ip = '.'.join(ip_list[:-1]) + '.'
    
    devices = []

    def worker(ip):
        if ping(ip):
            mac = get_mac(ip)
            if mac is not None:
              devices.append((ip, mac))

    threads = []
    for i in range(1, 255):  # Adjust range based on subnet mask
        ip = base_ip + str(i)
        thread = threading.Thread(target=worker, args=(ip,))
        thread.start()
        threads.append(thread)
    
    for thread in threads:
        thread.join()
    
    return devices

def LAN_addr(ip_addr: str):
    return f'TCPIP::{ip_addr}::INSTR'



rm = pyvisa.ResourceManager('@py')

class VISA_inst():
    """
    A base class for handling communication with instruments via the VISA interface.

    Attributes:
        dev (pyvisa.Resource): The instrument resource object for communication.
    """

    def __init__(self, instr_name: str) -> None:
        """
        Initializes the VISA instrument connection.

        Args:
            rm (pyvisa.ResourceManager): The resource manager object from PyVISA.
            instr_name (str): The name of the instrument to connect to.
        """
        self.dev = rm.open_resource(LAN_addr(Lab_Instruments[instr_name]["ip_addr"]))
        self.dev.read_termination = '\n'
        self.dev.write_termination = '\n'


class SA_Rigol(VISA_inst):
    """
    A class for controlling a Rigol Spectrum Analyzer using the VISA interface.

    Inherits from the VISA_inst class.

    Attributes:
        dev (pyvisa.Resource): The instrument resource object for communication.
    """

    def __init__(self) -> None:
        """
        Initializes the SPA_Rigol object and sets the trace mode.

        Args:
            rm (pyvisa.ResourceManager): The resource manager object from PyVISA.
        """
        instr_name = "SA_Rigol"
        super().__init__(instr_name=instr_name)
        

    def Set_Trace_Write(self):
        self.dev.write(f':TRACe1:MODE WRIT')
        
    def Set_Scale(self, scale: str):
        """
        Sets the y-axis scale of the display.

        Args:
            scale (str): The desired scale for the y-axis. Can be 'LINear' or 'LOGarithmic'.
        """
        self.dev.write(f':DISP:WIN:TRAC:Y:SCAL:SPAC {scale}')

    def Set_AutoRangeY(self):
        """
        Automatically adjusts the y-axis scale to ensure the signal peak spans the entire vertical range of the display.
        """
        self.dev.write(":POWer:ASCale")

    def Set_Span(self, span: float):
        """
        Sets the frequency span of the spectrum analyzer.

        Args:
            span (float): The frequency span to set, in Hz.
        """
        self.dev.write(f':FREQ:SPAN {span}')

    def Set_Center_Freq(self, freq: float):
        """
        Sets the center frequency of the spectrum analyzer.

        Args:
            freq (float): The center frequency to set, in Hz.
        """
        self.dev.write(f':FREQ:CENT {freq}')

    def Set_TraceType(self, trace=1, trace_type='WRIT'):
        """
        Configures the type of trace operation.

        Args:
            trace (int): The trace number to configure (default is 1).
            trace_type (str): The trace mode. Options include 'WRITe', 'MAXHold', 'MINHold', 
                              'VIEW', 'BLANk', 'VIDeoavg', 'POWeravg'.
        """
        self.dev.write(f':TRACe<{trace}:MODE {trace_type}')

    def Get_Peak(self, span_about_cent=1e8):
        """
        Finds the peak signal in the current trace and centers the frequency around it.

        Args:
            span_about_cent (float): The span to set around the center frequency, in Hz (default is 2e8).

        Returns:
            tuple: A tuple containing the frequency (X coordinate) and amplitude (Y coordinate) of the peak.
        """
        self.dev.write(':CALC:MARK1:MAX:MAx')  # Find the peak on the right side
        self.dev.write(':CALC:MARK1:SET:CENT')  # Center about marker 1
        self.dev.write(f':FREQ:SPAN {span_about_cent}')
        time.sleep(1)
        self.dev.write(':CALC:MARK1:MAX:MAx')
        freq = self.dev.query(':CALC:MARK1:X?')  # Get X coordinate (frequency)
        height = self.dev.query(':CALC:MARK1:Y?')  # Get Y coordinate (amplitude)
        return freq, height
    
    def Get_Trace(self, file_name: str, trace=1):
        ans = self.dev.query(f":TRACE{trace}:MODE?")
        if ans.startswith("BLAN"):
            print("Empty trace!")
            exit()
        else:
            #X
            pts = int(self.dev.query(":SWE:POIN?"))
            start = float(self.dev.query(":FREQ:STAR?"))
            stop = float(self.dev.query(":FREQ:STOP?"))
            x = np.linspace(start, stop, num=pts)
            
            # Y units, RBW
            units = self.dev.query(":UNIT:POW?").rstrip()
            rb = self.dev.query(":SENS:BAND:RES?").rstrip()
            vb = self.dev.query(":SENS:BAND:VID?").rstrip()
            swt = self.dev.query(":SENS:SWE:TIME?").rstrip()
            
            # Y
            self.dev.write(":FORM:TRAC:DATA REAL,32")
            self.dev.write(":FORM:BORD NORM")
            y = self.dev.query_binary_values(f":TRAC:DATA? TRACE{trace}")
        
        with open(file_name, 'w') as file:
            #output
            file.write("#\n# Y UNITS = %s\n#" % (units))
            file.write("# RES BW = %s\n#" % (rb))
            file.write("# VIDEO BW = %s\n#" % (vb))
            file.write("# SWEEP TIME = %s\n" % (swt))
            file.write('Freq,Amp\n')
            
            for i in range(pts):
                file.write("%e, %e\n" % (x[i], y[i]))
    
    def Save_Result(self, file_name: str):
        self.dev.write(f':MMEMory:STORe:RESults E:\{file_name}')
        
    def Save_Trace(self, file_name: str, tr_label= 'TRACE1'):
        """
        Saves the current trace data to a file on the device's storage.

        Args:
            file_name (str): The name of the file to save the trace to.
            tr_label (str): The trace label to save (default is 'TRACE1').
        """
        self.dev.write(f':MMEM:STOR:TRAC {tr_label},E:{file_name}')

    

class DMM(VISA_inst):
    def __init__(self) -> None:
        instr_name = "DMM"
        super().__init__(instr_name=instr_name)
    
    def Read_Meas(self):
        return float(self.dev.query('MEAS:VOLT:DC?'))



class Osc_RS(VISA_inst):
    """
    A class to control and retrieve data from the R&S RTM3000 oscilloscope using SCPI commands over VISA.
    
    Attributes
    ----------
    instr_name : str
        The name of the instrument.
    channel : int
        The oscilloscope channel to operate on, defaulting to channel 2.
    
    Methods
    -------
    Set_Channel(channel=2)
        Sets the active channel for measurements with validation.
        
    Set_coupling(coupling='DC')
        Sets the coupling for the current channel (DC or AC).
        
    Set_vertical_range(range=1.0)
        Sets the vertical range for the current channel in volts.
        
    Set_horizontal_range(range=1.0)
        Sets the horizontal (time) range in seconds.
        
    Start_acquisition()
        Starts data acquisition on the oscilloscope.
        
    Stop_acquisition()
        Stops data acquisition on the oscilloscope.
        
    Check_acquisition_complete()
        Checks if the acquisition is complete and ready for data retrieval.
        
    Get_Data()
        Retrieves waveform data from the oscilloscope. Returns the x (time) and y (voltage) data arrays.
        
    Acquire_and_Get_Data()
        Automates acquisition and data retrieval in one step.
    """

    def __init__(self, channel=2, data_format='REAL') -> None:
        """
        Initializes the Osc_RS object with default channel and data format for the RTM3000 oscilloscope.
        
        Parameters
        ----------
        channel : int, optional
            The oscilloscope channel to use, by default 2.
        data_format : str, optional
            Data format for waveform (e.g., 'REAL'), by default 'UINT,16'.
        """
        instr_name = "Osc_RS"
        self.channel = channel
        super().__init__(instr_name=instr_name)

        # Configure device with maximum data points and data format
        self.Set_data_format(data_format)
        self.dev.write('FORM:BORD LSBF')
        self.dev.write('CHAN:DATA:POIN DMAX')
        
    def Set_Channel(self, channel=2):
        """
        Sets the active channel for measurements after validation.
        
        Parameters
        ----------
        channel : int
            The channel number (1, 2, 3, or 4) depending on the oscilloscope model.
        
        Raises
        ------
        ValueError
            If the channel number is out of the oscilloscopeâ€™s supported range.
        """
        if channel not in (1, 2, 3, 4):  # RTM3004 supports up to 4 channels
            raise ValueError(f"Channel {channel} is not valid. Select a supported channel.")
        
        self.channel = channel
        
        for channel in (1, 2, 3, 4):
            self.dev.write(f'CHAN{channel}:STAT OFF')
        self.dev.write(f'CHAN{self.channel}:STAT ON')

    def Set_data_format(self, data_format='REAL'):
        """
        Sets the data format for waveform retrieval.
        
        Parameters
        ----------
        data_format : str
            SCPI data format, e.g., 'UINT,16'.
        """
        self.dev.write(f'FORM {data_format}')
        
    def Set_coupling(self, coupling='DC'):
        """
        Sets the input coupling mode for the current channel.
        
        Parameters
        ----------
        coupling : str
            Coupling mode, either 'DC' or 'AC'.
        """
        self.dev.write(f'CHAN{self.channel}:COUP {coupling}')
        
    def Set_vertical_range(self, range=1.0):
        """
        Sets the vertical range in volts for the specified channel.
        
        Parameters
        ----------
        range : float
            The vertical range in volts.
        """
        self.dev.write(f'CHAN{self.channel}:RANGe {range}')
        
    def Set_horizontal_range(self, range=1.0):
        """
        Sets the horizontal (time) range in seconds.
        
        Parameters
        ----------
        range : float
            The horizontal range in seconds.
        """
        self.dev.write(f'TIMebase:RANGe {range}')
    
    def Start_single(self):
        """
        Starts single acquisition on the oscilloscope.
        """
        self.dev.write('SING')
    
    def Start_acquisition(self):
        """
        Starts single acquisition on the oscilloscope.
        """
        self.dev.write('RUN')
    
    def Stop_acquisition(self):
        """
        Stops acquisition on the oscilloscope.
        """
        self.dev.write('STOP')
        
    def Check_acquisition_complete(self):
        """
        Checks if acquisition is complete using the *OPC? command.

        Returns
        -------
        bool
            True if acquisition is complete, otherwise False.
        """
        return self.dev.query('*OPC?') == '1'

    def Get_Data(self):
        """
        Retrieves waveform data from the oscilloscope.
        
        Returns
        -------
        tuple
            A tuple containing x_data and y_data as NumPy arrays.
        
        Raises
        ------
        RuntimeError
            If data retrieval fails or acquisition is incomplete.
        """
        if not self.Check_acquisition_complete():
            raise RuntimeError("Acquisition not complete or device not ready.")
        
        try:
            # Retrieve waveform header information
            header = self.dev.query(f'CHAN{self.channel}:DATA:HEAD?')
            x_min, x_max, record_length, _ = map(float, header.split(','))
            print(f'x_min = {x_min}, x_max = {x_max}, record_length = {record_length}')
            # Retrieve waveform data
            raw_data = self.dev.query_binary_values(f'CHAN{self.channel}:DATA?', datatype='f', is_big_endian=False)
            y_data = np.array(raw_data)

            # Generate x-axis time values based on header information
            dx = (x_max - x_min) / record_length
            x_data = np.arange(0, record_length) * dx
            
            return x_data, y_data
        
        except Exception as e:
            raise RuntimeError(f"Failed to retrieve data: {e}")
        
    def Acquire_and_Get_Data(self):
        """
        Starts acquisition, waits for completion, and retrieves waveform data.
        
        Returns
        -------
        tuple
            A tuple containing x_data and y_data as NumPy arrays.
        """
        self.Start_acquisition()
        if self.Check_acquisition_complete():
            time.sleep(1)
            return self.Get_Data()
        else:
            raise RuntimeError("Acquisition failed to complete.")



class Func_Gen(VISA_inst):
    def __init__(self) -> None:
        instr_name = "FuncGen_Rigol"
        super().__init__(instr_name=instr_name)
    
    def Set_Func(self, Func=''):
        self.dev.write(f':SOUR1:FUNC {Func}')
        
    def Set_Amp(self, Amp: float):
        self.dev.write(f':SOUR1:VOLT {Amp}')
    
    def Set_Freq(self, Freq: float):
        self.dev.write(f':SOUR1:FREQ {Freq}')
    
    def Set_Offset(self, Offset: float):
        self.dev.write(f':SOUR1:VOLT:OFFS {Offset}')
        
    def Set_Output(self, State: str):
        self.dev.write(f':OUTP1 {State}')
    
    


















# if __name__ == "__main__":
#     ip_range = "192.168.1.1/24"
#     devices = scan_network(ip_range)

#     print("\nDevices found:")
#     for ip, mac in devices:
#         print(f"IP: {ip}, MAC: {mac}")